# Spec 070: Rustle Exec Tool

## Feature Summary

The `rustle-exec` tool is the specialized task executor that runs individual tasks and orchestrated execution plans on target hosts. It consumes execution plans from `rustle-plan`, manages task execution state, handles error recovery, and provides real-time execution feedback with comprehensive logging and reporting.

**Problem it solves**: Separates task execution from planning and parsing, enabling optimized execution engines, better error handling, and execution state management without the overhead of parsing and planning.

**High-level approach**: Create a standalone binary that reads execution plans, executes tasks through module plugins, manages execution state and error recovery, and provides detailed execution reporting and logging.

## Goals & Requirements

### Functional Requirements
- Execute tasks from execution plans generated by rustle-plan
- Support all Ansible-compatible modules through plugin system
- Manage execution state and task dependencies
- Handle error recovery and retry logic
- Provide real-time execution feedback and progress reporting
- Support dry-run and check mode execution
- Implement handler triggering and execution
- Support execution strategies (linear, rolling, parallel)
- Generate detailed execution reports and logs
- Support task delegation and local execution

### Non-functional Requirements
- **Performance**: Execute 1000 tasks across 100 hosts in &lt;2 minutes
- **Reliability**: 99.9% task execution accuracy with proper error handling
- **Scalability**: Handle 1000+ concurrent task executions efficiently
- **Recovery**: Automatic retry and recovery from transient failures
- **Observability**: Comprehensive logging and metrics for execution monitoring

### Success Criteria
- All existing Rustle modules execute correctly through rustle-exec
- Execution performance is 10x+ faster than Ansible
- Error recovery reduces failure rates by 50% in unstable environments
- Real-time execution feedback enables better operational visibility
- Handler execution is reliable and properly sequenced

## API/Interface Design

### Command Line Interface
```bash
rustle-exec [OPTIONS] [EXECUTION_PLAN]

OPTIONS:
    -i, --inventory &lt;FILE&gt;         Inventory file with host information
    -l, --limit &lt;PATTERN&gt;          Limit execution to specific hosts
    -t, --tags &lt;TAGS&gt;              Only execute tasks with these tags
    --skip-tags &lt;TAGS&gt;             Skip tasks with these tags
    -c, --check                    Run in check mode (no changes)
    --diff                         Show differences for file changes
    --start-at-task &lt;TASK&gt;        Start execution at specific task
    --step                         Execute tasks step-by-step with confirmation
    --dry-run                      Show what would be executed without running
    -f, --forks &lt;NUM&gt;              Maximum parallel executions [default: 50]
    --serial &lt;NUM&gt;                 Execute on specified number of hosts at once
    --strategy &lt;STRATEGY&gt;          Execution strategy [default: linear]
    --connection-plugin &lt;PLUGIN&gt;   Connection method [default: ssh]
    --timeout &lt;SECONDS&gt;            Task execution timeout [default: 600]
    --retries &lt;NUM&gt;                Default number of retries [default: 3]
    --retry-delay &lt;SECONDS&gt;        Delay between retries [default: 5]
    --continue-on-error            Continue execution despite task failures
    --report-file &lt;FILE&gt;           Execution report output file
    --log-file &lt;FILE&gt;              Execution log file
    --progress &lt;MODE&gt;              Progress display mode [default: auto]
    -v, --verbose                  Enable verbose output
    --module-path &lt;DIR&gt;            Additional module search directories
    --facts-cache &lt;DIR&gt;            Facts cache directory
    --gather-facts                 Gather facts before execution
    --cleanup-on-failure           Clean up resources on execution failure

ARGS:
    &lt;EXECUTION_PLAN&gt;  Path to execution plan file (or stdin if -)
```

### Core Data Structures

```rust
// Execution state management
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionContext {
    pub execution_id: String,
    pub plan: ExecutionPlan,
    pub inventory: ParsedInventory,
    pub facts: HashMap&lt;String, HostFacts&gt;,
    pub global_vars: HashMap&lt;String, Value&gt;,
    pub execution_state: ExecutionState,
    pub start_time: DateTime&lt;Utc&gt;,
    pub options: ExecutionOptions,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionState {
    pub current_play: Option&lt;String&gt;,
    pub current_batch: Option&lt;String&gt;,
    pub completed_tasks: HashSet&lt;String&gt;,
    pub failed_tasks: HashSet&lt;String&gt;,
    pub skipped_tasks: HashSet&lt;String&gt;,
    pub triggered_handlers: HashMap&lt;String, Vec&lt;String&gt;&gt;,
    pub host_states: HashMap&lt;String, HostExecutionState&gt;,
    pub task_results: HashMap&lt;String, TaskResult&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HostExecutionState {
    pub status: HostStatus,
    pub current_task: Option&lt;String&gt;,
    pub completed_tasks: u32,
    pub failed_tasks: u32,
    pub last_error: Option&lt;String&gt;,
    pub unreachable: bool,
    pub gathered_facts: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HostStatus {
    Ready,
    Executing { task_id: String },
    Failed { error: String },
    Unreachable,
    Completed,
}

// Task execution results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskResult {
    pub task_id: String,
    pub task_name: String,
    pub host: String,
    pub status: TaskStatus,
    pub changed: bool,
    pub failed: bool,
    pub skipped: bool,
    pub start_time: DateTime&lt;Utc&gt;,
    pub end_time: Option&lt;DateTime&lt;Utc&gt;&gt;,
    pub duration: Option&lt;Duration&gt;,
    pub result: Option&lt;Value&gt;,
    pub error: Option&lt;String&gt;,
    pub stdout: Option&lt;String&gt;,
    pub stderr: Option&lt;String&gt;,
    pub return_code: Option&lt;i32&gt;,
    pub diff: Option&lt;TaskDiff&gt;,
    pub retry_count: u32,
    pub delegated_to: Option&lt;String&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TaskStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Skipped,
    Retrying,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskDiff {
    pub before: Option&lt;String&gt;,
    pub after: Option&lt;String&gt;,
    pub diff_lines: Vec&lt;String&gt;,
}

// Execution reporting
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionReport {
    pub execution_id: String,
    pub start_time: DateTime&lt;Utc&gt;,
    pub end_time: DateTime&lt;Utc&gt;,
    pub duration: Duration,
    pub summary: ExecutionSummary,
    pub host_results: HashMap&lt;String, HostSummary&gt;,
    pub task_results: Vec&lt;TaskResult&gt;,
    pub failures: Vec&lt;ExecutionFailure&gt;,
    pub performance_metrics: PerformanceMetrics,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionSummary {
    pub total_tasks: u32,
    pub successful_tasks: u32,
    pub failed_tasks: u32,
    pub skipped_tasks: u32,
    pub changed_tasks: u32,
    pub total_hosts: u32,
    pub successful_hosts: u32,
    pub unreachable_hosts: u32,
    pub failed_hosts: u32,
}
```

### Execution Engine API

```rust
pub struct ExecutionEngine {
    module_loader: ModuleLoader,
    connection_manager: Arc&lt;ConnectionManager&gt;,
    config: ExecutionConfig,
    state_manager: StateManager,
    reporter: ExecutionReporter,
}

impl ExecutionEngine {
    pub fn new(config: ExecutionConfig) -&gt; Result&lt;Self, ExecutionError&gt;;
    
    pub async fn execute_plan(
        &amp;self,
        plan: ExecutionPlan,
        inventory: ParsedInventory,
        options: ExecutionOptions,
    ) -&gt; Result&lt;ExecutionReport, ExecutionError&gt;;
    
    pub async fn execute_task(
        &amp;self,
        task: &amp;TaskPlan,
        host: &amp;str,
        context: &amp;ExecutionContext,
    ) -&gt; Result&lt;TaskResult, ExecutionError&gt;;
    
    pub async fn execute_handler(
        &amp;self,
        handler: &amp;HandlerPlan,
        host: &amp;str,
        context: &amp;ExecutionContext,
    ) -&gt; Result&lt;TaskResult, ExecutionError&gt;;
    
    pub fn pause_execution(&amp;self, execution_id: &amp;str) -&gt; Result&lt;(), ExecutionError&gt;;
    pub fn resume_execution(&amp;self, execution_id: &amp;str) -&gt; Result&lt;(), ExecutionError&gt;;
    pub fn cancel_execution(&amp;self, execution_id: &amp;str) -&gt; Result&lt;(), ExecutionError&gt;;
    
    pub fn get_execution_status(
        &amp;self, 
        execution_id: &amp;str
    ) -&gt; Result&lt;ExecutionState, ExecutionError&gt;;
}

// Module execution interface
pub trait ModuleExecutor: Send + Sync {
    fn name(&amp;self) -&gt; &amp;str;
    fn supports_check_mode(&amp;self) -&gt; bool;
    fn supports_diff(&amp;self) -&gt; bool;
    
    async fn execute(
        &amp;self,
        args: &amp;HashMap&lt;String, Value&gt;,
        context: &amp;TaskExecutionContext,
    ) -&gt; Result&lt;ModuleResult, ModuleError&gt;;
    
    async fn validate_args(
        &amp;self,
        args: &amp;HashMap&lt;String, Value&gt;,
    ) -&gt; Result&lt;(), ModuleError&gt;;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleResult {
    pub changed: bool,
    pub failed: bool,
    pub msg: Option&lt;String&gt;,
    pub result: HashMap&lt;String, Value&gt;,
    pub diff: Option&lt;TaskDiff&gt;,
    pub warnings: Vec&lt;String&gt;,
}
```

### Error Handling

```rust
#[derive(Debug, thiserror::Error)]
pub enum ExecutionError {
    #[error("Task '{task}' failed on host '{host}': {reason}")]
    TaskFailed { task: String, host: String, reason: String },
    
    #[error("Host '{host}' is unreachable: {reason}")]
    HostUnreachable { host: String, reason: String },
    
    #[error("Module '{module}' not found or failed to load")]
    ModuleNotFound { module: String },
    
    #[error("Invalid execution plan: {reason}")]
    InvalidPlan { reason: String },
    
    #[error("Execution timeout for task '{task}' on host '{host}'")]
    ExecutionTimeout { task: String, host: String },
    
    #[error("Maximum retries exceeded for task '{task}' on host '{host}'")]
    MaxRetriesExceeded { task: String, host: String },
    
    #[error("Handler '{handler}' failed: {reason}")]
    HandlerFailed { handler: String, reason: String },
    
    #[error("State management error: {message}")]
    StateError { message: String },
    
    #[error("Connection error: {message}")]
    ConnectionError { message: String },
    
    #[error("Resource limit exceeded: {resource}")]
    ResourceLimitExceeded { resource: String },
}
```

## File and Package Structure

```
src/bin/rustle-exec.rs          # Main binary entry point
src/executor/
├── mod.rs                      # Module exports
├── engine.rs                   # Core execution engine
├── state.rs                    # Execution state management
├── strategy.rs                 # Execution strategies
├── module_loader.rs            # Module loading and management
├── handler.rs                  # Handler execution
├── retry.rs                    # Retry logic and recovery
├── progress.rs                 # Progress reporting
├── reporter.rs                 # Execution reporting
└── error.rs                    # Error types

src/modules/
├── mod.rs                      # Module registry
├── command.rs                  # Command module
├── copy.rs                     # Copy module
├── file.rs                     # File module
├── template.rs                 # Template module
├── service.rs                  # Service module
├── package.rs                  # Package module
├── user.rs                     # User module
├── group.rs                    # Group module
└── shell.rs                    # Shell module

src/strategies/
├── mod.rs                      # Strategy exports
├── linear.rs                   # Linear execution
├── rolling.rs                  # Rolling execution
├── parallel.rs                 # Parallel execution
└── batch.rs                    # Batch execution

tests/executor/
├── engine_tests.rs
├── module_tests.rs
├── strategy_tests.rs
├── retry_tests.rs
└── integration_tests.rs
```

## Implementation Details

### Phase 1: Core Execution Engine
1. Implement basic execution engine with state management
2. Create module loading and execution framework
3. Add task execution with basic error handling
4. Implement linear execution strategy

### Phase 2: Advanced Execution Features
1. Add retry logic and error recovery
2. Implement handler triggering and execution
3. Add check mode and diff support
4. Create execution reporting and logging

### Phase 3: Execution Strategies
1. Implement rolling execution strategy
2. Add parallel execution optimization
3. Create batch execution for large inventories
4. Add execution strategy selection logic

### Phase 4: Monitoring and Observability
1. Add real-time progress reporting
2. Implement comprehensive metrics collection
3. Create execution state persistence
4. Add performance profiling and optimization

### Key Algorithms

**Task Execution with Retry Logic**:
```rust
async fn execute_task_with_retry(
    &amp;self,
    task: &amp;TaskPlan,
    host: &amp;str,
    context: &amp;ExecutionContext,
) -&gt; Result&lt;TaskResult, ExecutionError&gt; {
    let mut retry_count = 0;
    let max_retries = task.retries.unwrap_or(self.config.default_retries);
    let retry_delay = task.retry_delay.unwrap_or(self.config.default_retry_delay);
    
    loop {
        let start_time = Utc::now();
        
        let result = self.execute_single_task(task, host, context).await;
        
        match result {
            Ok(mut task_result) =&gt; {
                task_result.retry_count = retry_count;
                return Ok(task_result);
            }
            Err(error) if retry_count &lt; max_retries &amp;&amp; error.is_retryable() =&gt; {
                retry_count += 1;
                
                tracing::warn!(
                    "Task '{}' failed on host '{}' (attempt {}/{}): {}",
                    task.name, host, retry_count, max_retries + 1, error
                );
                
                if retry_count &lt; max_retries {
                    tokio::time::sleep(retry_delay).await;
                    continue;
                }
                
                return Err(ExecutionError::MaxRetriesExceeded {
                    task: task.name.clone(),
                    host: host.to_string(),
                });
            }
            Err(error) =&gt; {
                return Err(error);
            }
        }
    }
}
```

**Rolling Execution Strategy**:
```rust
async fn execute_rolling_strategy(
    &amp;self,
    play: &amp;PlayPlan,
    context: &amp;ExecutionContext,
) -&gt; Result&lt;Vec&lt;TaskResult&gt;, ExecutionError&gt; {
    let mut all_results = Vec::new();
    let batch_size = play.serial.unwrap_or(1);
    let total_hosts = play.hosts.len();
    
    for batch_start in (0..total_hosts).step_by(batch_size as usize) {
        let batch_end = std::cmp::min(batch_start + batch_size as usize, total_hosts);
        let batch_hosts = &amp;play.hosts[batch_start..batch_end];
        
        tracing::info!(
            "Executing rolling batch {}-{} of {} hosts",
            batch_start + 1, batch_end, total_hosts
        );
        
        // Execute all tasks for this batch of hosts
        let batch_results = self.execute_batch_parallel(
            &amp;play.batches[0].tasks,
            batch_hosts,
            context,
        ).await?;
        
        // Check for failures - rolling strategy fails fast
        let failed_hosts: Vec&lt;_&gt; = batch_results
            .iter()
            .filter(|result| result.failed)
            .map(|result| &amp;result.host)
            .collect();
        
        if !failed_hosts.is_empty() &amp;&amp; !context.options.continue_on_error {
            return Err(ExecutionError::TaskFailed {
                task: "batch".to_string(),
                host: failed_hosts[0].clone(),
                reason: format!("Rolling deployment failed on hosts: {:?}", failed_hosts),
            });
        }
        
        all_results.extend(batch_results);
        
        // Execute handlers for this batch
        if !play.handlers.is_empty() {
            let handler_results = self.execute_handlers(
                &amp;play.handlers,
                batch_hosts,
                context,
            ).await?;
            all_results.extend(handler_results);
        }
    }
    
    Ok(all_results)
}
```

**Module Execution Framework**:
```rust
async fn execute_module(
    &amp;self,
    module_name: &amp;str,
    args: &amp;HashMap&lt;String, Value&gt;,
    context: &amp;TaskExecutionContext,
) -&gt; Result&lt;ModuleResult, ExecutionError&gt; {
    // Load module executor
    let module = self.module_loader.get_module(module_name)
        .ok_or_else(|| ExecutionError::ModuleNotFound {
            module: module_name.to_string(),
        })?;
    
    // Validate arguments
    module.validate_args(args).await
        .map_err(|e| ExecutionError::TaskFailed {
            task: context.task_name.clone(),
            host: context.host.clone(),
            reason: format!("Argument validation failed: {}", e),
        })?;
    
    // Check if we should run in check mode
    if context.check_mode &amp;&amp; !module.supports_check_mode() {
        return Ok(ModuleResult {
            changed: false,
            failed: false,
            msg: Some("Check mode not supported".to_string()),
            result: HashMap::new(),
            diff: None,
            warnings: vec!["Module does not support check mode".to_string()],
        });
    }
    
    // Set up execution timeout
    let execution_future = module.execute(args, context);
    let timeout_duration = context.timeout.unwrap_or(Duration::from_secs(600));
    
    match tokio::time::timeout(timeout_duration, execution_future).await {
        Ok(result) =&gt; result.map_err(|e| ExecutionError::TaskFailed {
            task: context.task_name.clone(),
            host: context.host.clone(),
            reason: e.to_string(),
        }),
        Err(_) =&gt; Err(ExecutionError::ExecutionTimeout {
            task: context.task_name.clone(),
            host: context.host.clone(),
        }),
    }
}
```

**Handler Triggering Logic**:
```rust
async fn process_task_notifications(
    &amp;self,
    task_result: &amp;TaskResult,
    task_plan: &amp;TaskPlan,
    context: &amp;mut ExecutionContext,
) -&gt; Result&lt;(), ExecutionError&gt; {
    // Only trigger handlers if task changed and succeeded
    if !task_result.changed || task_result.failed {
        return Ok(());
    }
    
    for handler_name in &amp;task_plan.notify {
        // Add handler to the triggered list for this host
        let host_handlers = context.execution_state
            .triggered_handlers
            .entry(task_result.host.clone())
            .or_insert_with(Vec::new);
        
        if !host_handlers.contains(handler_name) {
            host_handlers.push(handler_name.clone());
            
            tracing::debug!(
                "Handler '{}' triggered by task '{}' on host '{}'",
                handler_name, task_result.task_name, task_result.host
            );
        }
    }
    
    Ok(())
}

async fn execute_triggered_handlers(
    &amp;self,
    handlers: &amp;[HandlerPlan],
    host: &amp;str,
    context: &amp;ExecutionContext,
) -&gt; Result&lt;Vec&lt;TaskResult&gt;, ExecutionError&gt; {
    let triggered_handlers = context.execution_state
        .triggered_handlers
        .get(host)
        .cloned()
        .unwrap_or_default();
    
    let mut results = Vec::new();
    
    for handler in handlers {
        if triggered_handlers.contains(&amp;handler.name) {
            tracing::info!("Executing handler '{}' on host '{}'", handler.name, host);
            
            let handler_result = self.execute_handler(handler, host, context).await?;
            results.push(handler_result);
        }
    }
    
    Ok(results)
}
```

## Testing Strategy

### Unit Tests
- **Task execution**: Test individual task execution with various modules
- **Retry logic**: Test retry behavior with different failure scenarios
- **Handler triggering**: Test handler notification and execution logic
- **Execution strategies**: Test different execution strategies and their behavior
- **Error handling**: Test error scenarios and recovery mechanisms

### Integration Tests
- **End-to-end execution**: Test complete execution plan processing
- **Multi-host execution**: Test parallel execution across multiple hosts
- **Complex playbooks**: Test execution of complex multi-play playbooks
- **Error recovery**: Test resilience with various failure conditions
- **Performance**: Test execution speed and resource usage

### Test Data Structure
```
tests/fixtures/
├── execution_plans/
│   ├── simple_plan.json        # Basic execution plan
│   ├── rolling_plan.json       # Rolling deployment plan
│   ├── parallel_plan.json      # Parallel execution plan
│   └── handler_plan.json       # Plan with handlers
├── modules/
│   ├── test_module.rs         # Test module implementation
│   └── mock_module.rs         # Mock module for testing
└── expected_results/
    ├── simple_results.json     # Expected execution results
    └── error_scenarios.json   # Expected error conditions
```

### Performance Benchmarks
- Task execution speed vs. Ansible
- Memory usage during large executions
- Parallel execution efficiency
- Handler execution performance

## Edge Cases &amp; Error Handling

### Task Execution Issues
- Module failures and error recovery
- Timeout handling for long-running tasks
- Resource exhaustion during execution
- Dependency failures and cascading errors

### Network and Connectivity
- Host unreachability during execution
- Connection timeouts and recovery
- Partial execution completion
- Network partitions and split-brain scenarios

### State Management
- Execution state persistence and recovery
- Concurrent execution management
- State corruption and recovery
- Memory limits with large state objects

### Handler Execution
- Handler dependency ordering
- Failed handler recovery
- Handler notification reliability
- Circular handler dependencies

## Dependencies

### External Crates
```toml
[dependencies]
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tokio = { version = "1", features = ["full"] }
clap = { version = "4", features = ["derive"] }
anyhow = "1"
thiserror = "1"
tracing = "0.1"
uuid = { version = "1", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
futures = "0.3"
async-trait = "0.1"
dashmap = "5"
```

### Internal Dependencies
- `rustle::types` - Core type definitions
- `rustle::error` - Error handling
- `rustle-connect` - SSH connection management
- `rustle-plan` output types
- Module implementations

## Configuration

### Environment Variables
- `RUSTLE_MODULE_PATH`: Additional module search directories
- `RUSTLE_EXEC_TIMEOUT`: Default task execution timeout
- `RUSTLE_MAX_RETRIES`: Default maximum retries
- `RUSTLE_FORKS`: Default parallelism level
- `RUSTLE_LOG_LEVEL`: Execution logging level

### Configuration File Support
```toml
[executor]
default_timeout_secs = 600
default_retries = 3
default_retry_delay_secs = 5
max_forks = 100
continue_on_error = false
gather_facts_by_default = true

[modules]
search_paths = ["~/.rustle/modules", "/usr/local/rustle/modules"]
enable_custom_modules = true
module_timeout_secs = 300

[reporting]
enable_progress_reporting = true
report_format = "json"
log_failed_tasks = true
log_changed_tasks = true

[performance]
task_queue_size = 1000
connection_pool_size = 50
memory_limit_mb = 1000
```

## Documentation

### CLI Help Text
```
rustle-exec - Execute tasks from execution plans

USAGE:
    rustle-exec [OPTIONS] [EXECUTION_PLAN]

ARGS:
    &lt;EXECUTION_PLAN&gt;    Path to execution plan file (or stdin if -)

OPTIONS:
    -i, --inventory &lt;FILE&gt;         Inventory file with host information
    -l, --limit &lt;PATTERN&gt;          Limit execution to specific hosts
    -t, --tags &lt;TAGS&gt;              Only execute tasks with these tags
        --skip-tags &lt;TAGS&gt;         Skip tasks with these tags
    -c, --check                    Run in check mode (no changes)
        --diff                     Show differences for file changes
        --start-at-task &lt;TASK&gt;     Start execution at specific task
        --step                     Execute tasks step-by-step with confirmation
        --dry-run                  Show what would be executed without running
    -f, --forks &lt;NUM&gt;              Maximum parallel executions [default: 50]
        --timeout &lt;SECONDS&gt;        Task execution timeout [default: 600]
        --retries &lt;NUM&gt;            Default number of retries [default: 3]
        --continue-on-error        Continue execution despite task failures
        --report-file &lt;FILE&gt;       Execution report output file
    -v, --verbose                  Enable verbose output
    -h, --help                     Print help information
    -V, --version                  Print version information

EXAMPLES:
    rustle-exec plan.json                                      # Execute plan
    rustle-exec -c --diff plan.json                           # Check mode with diff
    rustle-exec --limit web_servers plan.json                 # Execute on specific hosts
    rustle-exec --start-at-task "Deploy application" plan.json # Start at specific task
    rustle-exec --step plan.json                              # Step-by-step execution
```

### API Documentation
Comprehensive rustdoc documentation covering:
- Module development guidelines
- Execution strategy implementation
- Error handling and recovery patterns
- Performance optimization techniques

### Integration Examples
```bash
# Complete execution pipeline
rustle-parse playbook.yml | \
  rustle-plan --optimize | \
  rustle-exec

# Check mode execution with reporting
rustle-exec --check --diff --report-file check_report.json plan.json

# Limited execution with specific strategy
rustle-exec --limit production --strategy rolling plan.json

# Parallel execution with custom forks
rustle-exec --forks 100 --timeout 120 large_deployment.json

# Step-by-step execution for debugging
rustle-exec --step --verbose debug_plan.json
```